<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MapillaryJS – fast pins (tile bboxes, 2k pages, canvas)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapillaryJS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
  <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #wrap { height: 100vh; width: 100%; }
    #mly, #map { height: 100%; width: 100%; }
    #msg { position: absolute; top: 8px; left: 8px; z-index: 1000;
           background: rgba(0,0,0,.6); color: #fff; padding: 6px 10px; border-radius: 6px;
           font: 13px/1.4 system-ui, sans-serif; white-space: pre-line; }
    #dbg { position: absolute; top: 8px; right: 8px; z-index: 1000;
           background: rgba(20,20,20,.72); color: #9ef; padding: 6px 10px; border-radius: 6px;
           font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; display:none; }
    .image-only { display:block; position:relative; }
    .image-only #map { display:none; }
    .map-only { display:block; }
    .map-only #mly { display:none; }
    .split { display:grid; grid-template-columns:1fr 1fr; }
    .split #mly, .split #map { display:block; }
  </style>
</head>
<body>
  <div id="wrap" class="split">
    <div id="mly" aria-label="Mapillary viewer"></div>
    <div id="map" aria-label="Map"></div>
    <div id="msg"></div>
    <pre id="dbg"></pre>
  </div>

  <script>
    // ------------------ Query/options ------------------
    const qs = new URLSearchParams(location.search);

    // Your token can be URL-encoded; decode to "MLY|..."
    const RAW_TOKEN = "MLY|7C24840280672250420|7C6fc0e204403850a11ccc043866f1b01d";
    const TOKEN = RAW_TOKEN;

    const defaults = {
      lat: Number(30.138307),
      lng: Number(-91.965153),
      z:   Number(16),
      username: "HKocen"
    };

    // Optional date filters via URL, e.g. ?after=2025-06-01&before=2025-12-31
    const AFTER  = qs.get("after")  && /^\d{4}-\d{2}-\d{2}$/.test(qs.get("after"))  ? qs.get("after")  + "T00:00:00Z" : "";
    const BEFORE = qs.get("before") && /^\d{4}-\d{2}-\d{2}$/.test(qs.get("before")) ? qs.get("before") + "T23:59:59Z" : "";

    const VIEW          = "split";                   // image | map | split
    const SHOW_PINS     = true;                      // show pins
    const FOV_DEG       = Number(60);
    const DEBUG         = qs.get("debug") === "1";

    // page + tiling perf knobs
    const MAX_PINS_TOTAL   = 5000;        // cap per refresh
    const PAGE_LIMIT       = 2000;        // docs: default/max 2000
    const TILE_TARGET_AREA = 0.009;       // deg² (must be < 0.01 per docs)
    const MAX_TILES        = 512;         // guardrail
    const CONCURRENCY      = 8;           // parallel tile fetchers
    const DEBOUNCE_MS      = 250;

    // Start on this image if provided:
    const START_IMAGE_ID = (qs.get("image") || "744575191439794").trim();

    const status = (t)=>{ document.getElementById('msg').textContent = t || ""; };
    const dbg    = (t)=>{ const el=document.getElementById('dbg'); if (DEBUG){ el.style.display='block'; el.textContent=t; } };

    // ------------------ Layout ------------------
    const wrap = document.getElementById('wrap');
    wrap.className = VIEW === 'split' ? 'split' : (VIEW === 'map' ? 'map-only' : 'image-only');

    const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
    const nextFrame = ()=>new Promise(r=>requestAnimationFrame(()=>requestAnimationFrame(r)));

    // ------------------ Leaflet map ------------------
    const map = L.map('map', { zoomControl:true, attributionControl:true });
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    const startLatLng = [defaults.lat, defaults.lng];
    const initialZoom = Math.max(0, (defaults.z || 16) - 2);
    map.setView(startLatLng, initialZoom);

    // Use a shared Canvas renderer (much faster for lots of circles than SVG)
    const canvasRenderer = L.canvas({ padding: 0.5 });

    const marker = L.marker(startLatLng, { draggable:false }).addTo(map);
    const pinLayer = L.featureGroup([], { renderer: canvasRenderer }).addTo(map);
    const orientationLayer = L.layerGroup().addTo(map);

    const defaultPinStyle = {
      radius: 3.5, color: '#1b5e20', weight: 2, opacity: 1,
      fillColor: '#2ecc71', fillOpacity: 0.9, renderer: canvasRenderer
    };

    const selectedPinStyle = {
      radius: 8, color: '#e53935', weight: 3, opacity: 1,
      fillColor: '#ffcdd2', fillOpacity: 1.0, renderer: canvasRenderer
    };

    let pinsById = new Map();
    let selectedPin = null;

    function styleDefault(layer){ try{ layer.setStyle(defaultPinStyle); }catch{} }
    function styleSelected(layer){ try{ layer.setStyle(selectedPinStyle); layer.bringToFront(); }catch{} }
    function selectPinById(imageId){
      const lyr = pinsById.get(imageId);
      if(!lyr) return;
      if(selectedPin && selectedPin !== lyr) styleDefault(selectedPin);
      styleSelected(lyr);
      selectedPin = lyr;
    }

    // ------------------ Helpers ------------------
    function clampLon(x){ return Math.max(-180, Math.min(180, x)); }
    function clampLat(y){ return Math.max(-85, Math.min(85, y)); }
    function bboxFromMap(m){
      const b=m.getBounds(), sw=b.getSouthWest(), ne=b.getNorthEast();
      const W=clampLon(sw.lng), S=clampLat(sw.lat), E=clampLon(ne.lng), N=clampLat(ne.lat);
      return [W,S,E,N];
    }
    function bboxArea([W,S,E,N]){ return Math.max(0,E-W)*Math.max(0,N-S); }
    function splitBbox([W,S,E,N]){
      const mx=(W+E)/2, my=(S+N)/2;
      return [[W,S,mx,my],[mx,S,E,my],[W,my,mx,N],[mx,my,E,N]];
    }

    // Build a set of small bboxes (< 0.01 deg²) covering the viewport
    function tileViewportBboxes(viewBbox){
      const out = [];
      const q = [viewBbox];
      while (q.length && out.length < MAX_TILES){
        const b = q.shift();
        if (bboxArea(b) <= TILE_TARGET_AREA) { out.push(b); continue; }
        q.push(...splitBbox(b));
      }
      return out;
    }

    function destPoint(lat,lng,bearingDeg,meters){
      const R=6371000, br=bearingDeg*Math.PI/180;
      const φ1=lat*Math.PI/180, λ1=lng*Math.PI/180, δ=meters/R;
      const φ2=Math.asin(Math.sin(φ1)*Math.cos(δ)+Math.cos(φ1)*Math.sin(δ)*Math.cos(br));
      const λ2=λ1+Math.atan2(Math.sin(br)*Math.sin(δ)*Math.cos(φ1), Math.cos(δ)-Math.sin(φ1)*Math.sin(φ2));
      return [φ2*180/Math.PI, ((λ2*180/Math.PI+540)%360)-180];
    }
    function drawOrientation(lat,lng,bearingDeg,fovDeg=FOV_DEG,length=50){
      orientationLayer.clearLayers();
      if(typeof bearingDeg!=='number') return;
      const left=bearingDeg-fovDeg/2, right=bearingDeg+fovDeg/2;
      const tip=destPoint(lat,lng,bearingDeg,length);
      const pLeft=destPoint(lat,lng,left,length);
      const pRight=destPoint(lat,lng,right,length);
      L.polygon([[lat,lng],pLeft,pRight],{color:'#1976d2',weight:1,fillColor:'#1976d2',fillOpacity:.18}).addTo(orientationLayer);
      L.polyline([[lat,lng],tip],{color:'#1976d2',weight:2,opacity:.9}).addTo(orientationLayer);
    }

    // ------------------ Graph API (faster + resilient) ------------------
    function buildImagesURL({bbox, limit}){
      const [W,S,E,N] = bbox.map(v => +v.toFixed(7));
      const u = new URL("https://graph.mapillary.com/images");
      u.searchParams.set("fields", "id,computed_geometry");
      u.searchParams.set("bbox", `${W},${S},${E},${N}`);  // west,south,east,north
      u.searchParams.set("limit", String(Math.min(PAGE_LIMIT, limit)));
      u.searchParams.set("access_token", TOKEN);
      if (defaults.username) u.searchParams.set("creator_username", defaults.username);
      if (AFTER)  u.searchParams.set("start_captured_at", AFTER);
      if (BEFORE) u.searchParams.set("end_captured_at", BEFORE);
      return u;
    }

    async function fetchTile({bbox, cap, signal}){
      const bboxStr = bbox.map(v => +v.toFixed(7)).join(",");
      let out = [];
      let url = buildImagesURL({bbox, limit: Math.min(PAGE_LIMIT, cap)});

      while (url && out.length < cap){
        const res = await fetch(url, { signal });
        if (!res.ok){
          const t = await res.text().catch(()=>res.statusText);
          throw new Error(`API ${res.status} ${t}`);
        }
        const j = await res.json();
        if (Array.isArray(j.data)) out.push(...j.data);

        const next = j?.paging?.next;
        if (next && out.length < cap) {
          url = new URL(next);

          // Re-attach filters the API might drop (esp. bbox)
          if (!url.searchParams.get("access_token"))      url.searchParams.set("access_token", TOKEN);
          if (!url.searchParams.get("fields"))            url.searchParams.set("fields", "id,computed_geometry");
          if (!url.searchParams.get("creator_username") && defaults.username)
            url.searchParams.set("creator_username", defaults.username);
          if (!url.searchParams.get("start_captured_at") && AFTER)  url.searchParams.set("start_captured_at", AFTER);
          if (!url.searchParams.get("end_captured_at")   && BEFORE) url.searchParams.set("end_captured_at", BEFORE);
          if (!url.searchParams.get("bbox"))                        url.searchParams.set("bbox", bboxStr);

          // Tighten the next page limit to remaining budget
          const remaining = cap - out.length;
          url.searchParams.set("limit", String(Math.min(PAGE_LIMIT, remaining)));
        } else {
          url = null;
        }
      }
      return out.slice(0, cap);
    }

    let currentAbort = null;

    async function drawPinsForView(){
      if (!TOKEN || !SHOW_PINS) return;

      // Cancel previous refresh
      if (currentAbort) currentAbort.abort();
      currentAbort = new AbortController();
      const { signal } = currentAbort;

      const t0 = performance.now();
      const tiles = tileViewportBboxes(bboxFromMap(map));
      status(`Loading pins… tiles: ${tiles.length}\nUser: ${defaults.username}${AFTER?`\nAfter: ${AFTER}`:""}${BEFORE?`\nBefore: ${BEFORE}`:""}`);

      // Parallel tile fetching with a global cap
      const seen = new Set();
      let remaining = MAX_PINS_TOTAL;
      let index = 0;
      const results = [];

      async function worker(){
        while (!signal.aborted && remaining > 0 && index < tiles.length){
          const my = index++;
          const capForTile = Math.min(PAGE_LIMIT, remaining);
          try{
            const data = await fetchTile({bbox: tiles[my], cap: capForTile, signal});
            for (const d of data){
              const id = d?.id;
              const c = d?.computed_geometry?.coordinates;
              if (!id || !Array.isArray(c)) continue;
              if (seen.has(id)) continue;
              seen.add(id);
              results.push({ id, lng: c[0], lat: c[1] });
              remaining--;
              if (remaining <= 0) break;
            }
          }catch(e){
            if (!signal.aborted) console.warn("Tile failed:", e.message || e);
          }
        }
      }
      const workers = Array.from({length: Math.min(CONCURRENCY, tiles.length)}, worker);
      await Promise.all(workers).catch(()=>{});

      if (signal.aborted) return;

      // (Re)draw pins fast with Canvas renderer
      pinLayer.clearLayers(); pinsById.clear(); selectedPin = null;

      results.forEach(r=>{
        const latlng = [r.lat, r.lng];
        const pin = L.circleMarker(latlng, defaultPinStyle)
          .on('click', async (e)=>{
            L.DomEvent.stop(e);
            selectPinById(r.id);
            await gotoImage(r.id, latlng);
          });
        pinLayer.addLayer(pin);
        pinsById.set(r.id, pin);
      });

      const ms = Math.round(performance.now() - t0);
      const capped = results.length >= MAX_PINS_TOTAL ? " (capped)" : "";
      status(`Pins: ${results.length}${capped}\nTiles: ${tiles.length}\nTime: ${ms} ms`);
    }

    let pinTimer=null;
    map.on('moveend', ()=>{ if(!SHOW_PINS) return; clearTimeout(pinTimer); pinTimer=setTimeout(drawPinsForView, DEBOUNCE_MS); });

    // ------------------ Viewer + sticky wedge ------------------
    function getRotationDeg(rootEl){
      if(!rootEl) return null;
      const q=[rootEl]; let depth=0, nextBreak=1, count=0, maxDepth=3;
      while(q.length && depth<=maxDepth){
        const el=q.shift();
        const t=getComputedStyle(el).transform || el.style?.transform || '';
        const deg=parseTransformToDeg(t); if(deg!=null) return (deg+360)%360;
        for(const ch of el.children||[]) q.push(ch);
        count++; if(count===nextBreak){ depth++; nextBreak=q.length+count; }
      }
      return null;
      function parseTransformToDeg(tr){
        if(!tr || tr==='none') return null;
        const r=/rotate[Z]?\(\s*([-+0-9.]+)\s*(deg|rad)\s*\)/i.exec(tr);
        if(r){ const v=parseFloat(r[1]); return r[2].toLowerCase()==='rad'? v*180/Math.PI : v; }
        const m2=/^matrix\(\s*([-+0-9eE.,\s]+)\)$/.exec(tr);
        if(m2){ const [a,b]=m2[1].split(',').map(x=>parseFloat(x)); return Math.atan2(b,a)*180/Math.PI; }
        const m3=/^matrix3d\(\s*([-+0-9eE.,\s]+)\)$/.exec(tr);
        if(m3){ const p=m3[1].split(',').map(x=>parseFloat(x)); return Math.atan2(p[1],p[0])*180/Math.PI; }
        return null;
      }
    }
    function getCompassRotation(){
      const host=document.getElementById('mly');
      const trySel=(sel,src)=>{ const el=host && host.querySelector(sel); const deg=getRotationDeg(el);
        return deg!=null ? {rot:((deg%360)+360)%360, src} : null; };
      return (
        trySel('.mapillary-bearing-indicator-background','bg') ||
        trySel('.mapillary-bearing-indicator-background-arrow','bg-arrow') ||
        trySel('.mapillary-bearing-north-container','north') ||
        trySel('[class*="bearing"]','fallback') ||
        {rot:null, src:'none'}
      );
    }

    let viewer, navLock=0;
    let compassOffset=0;
    let stickyBearing=((Number(qs.get("bearing")) || 270)+360)%360;
    let suspendWatcher=false;

    async function reanchorToSticky(){
      suspendWatcher = true;
      await nextFrame();
      const {rot} = getCompassRotation();
      if(rot!=null){
        compassOffset = ((stickyBearing - (-1) * rot) % 360 + 360) % 360;
        const p=marker.getLatLng();
        drawOrientation(p.lat, p.lng, stickyBearing, FOV_DEG, 50);
      }
      suspendWatcher = false;
    }

    function startCompassWatcher(){
      setInterval(()=>{
        if(suspendWatcher) return;
        const {rot} = getCompassRotation();
        if(rot==null) return;
        const bearing = (compassOffset + (-1) * rot) % 360;
        stickyBearing = bearing;
        const pos=marker.getLatLng();
        drawOrientation(pos.lat, pos.lng, bearing, FOV_DEG, 50);
      }, 120);
    }

    async function gotoImage(id, latlngHint){
      const my=++navLock;
      try{ await viewer.setFilter(["all"]); }catch{}
      try{
        suspendWatcher = true;
        await viewer.moveTo(id);

        if (SHOW_PINS) selectPinById(id);

        const ll = latlngHint || await getImageLatLng(id);
        if(ll){
          marker.setLatLng(ll);
          map.setView(ll, map.getZoom(), {animate:true});
        }
      } finally {
        if(navLock===my) navLock=0;
      }
    }

    async function findImageNear({lat,lng}){
      const url=new URL("https://graph.mapillary.com/images");
      url.searchParams.set("fields","id,computed_geometry");
      url.searchParams.set("closeto", `${lng},${lat}`);
      url.searchParams.set("radius", "50");
      url.searchParams.set("limit","1");
      if (defaults.username) url.searchParams.set("creator_username", defaults.username);
      if (AFTER)  url.searchParams.set("start_captured_at", AFTER);
      if (BEFORE) url.searchParams.set("end_captured_at", BEFORE);
      url.searchParams.set("access_token", TOKEN);
      const res=await fetch(url);
      if(!res.ok){ throw new Error(`API ${res.status}`); }
      const j=await res.json(); return j?.data?.[0] ?? null;
    }

    async function getImageLatLng(imageId){
      const u=new URL(`https://graph.mapillary.com/${imageId}`);
      u.searchParams.set("fields","computed_geometry");
      u.searchParams.set("access_token", TOKEN);
      const res=await fetch(u);
      if(!res.ok) return null;
      const j=await res.json();
      const c=j?.computed_geometry?.coordinates;
      return Array.isArray(c) && c.length===2 ? [c[1], c[0]] : null;
    }

    // ------------------ Init ------------------
    (async function init(){
      if(!TOKEN){ status("Add ?token=YOUR_TOKEN"); return; }
      const M=window.Mapillary || window.mapillary || window.mapillaryjs;
      const ViewerCtor=M && M.Viewer;
      if(!ViewerCtor){ status("Mapillary library failed to load."); return; }

      viewer=new ViewerCtor({ container:"mly", accessToken:TOKEN });
      try{ viewer.setFieldOfView(FOV_DEG); }catch{}

      try {
        viewer.on('image', async (ev)=>{
          const id=ev?.image?.id || ev?.imageId || ev?.id;
          if(!id) return;
          const latlng = await getImageLatLng(id);
          if(latlng){
            marker.setLatLng(latlng);
            map.setView(latlng, map.getZoom(), {animate:true});
          }
          if (SHOW_PINS) selectPinById(id);
          await reanchorToSticky();
        });
      } catch {}

      try{
        status(`Opening image ${START_IMAGE_ID}…`);
        await gotoImage(START_IMAGE_ID);
      }catch(e){
        status("Searching for a nearby image…");
        const start=await findImageNear({lat:defaults.lat, lng:defaults.lng});
        if(!start){ status(`No imagery by "${defaults.username}" near start.`); return; }
        await gotoImage(start.id);
      }

      await reanchorToSticky();
      status("");

      startCompassWatcher();
      if(SHOW_PINS) drawPinsForView();
    })();
  </script>
</body>
</html>
