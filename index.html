<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MapillaryJS — fast viewport pins (2000 page, retries, cache)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapillaryJS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
  <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #wrap { height: 100vh; width: 100%; }
    #mly, #map { height: 100%; width: 100%; }
    #msg { position: absolute; top: 8px; left: 8px; z-index: 1000;
           background: rgba(0,0,0,.72); color: #fff; padding: 6px 10px; border-radius: 6px;
           font: 13px/1.4 system-ui, sans-serif; white-space: pre-line; }
    .split { display:grid; grid-template-columns:1fr 1fr; }
    .split #mly, .split #map { display:block; }
  </style>
</head>
<body>
  <div id="wrap" class="split">
    <div id="mly"></div>
    <div id="map"></div>
    <div id="msg">Loading…</div>
  </div>

  <script>
    // ------------------ CONFIG ------------------
    const qs = new URLSearchParams(location.search);

    // token can be URL-encoded; decode -> MLY|...
    const RAW_TOKEN = "MLY%7C24840280672250420%7C6fc0e204403850a11ccc043866f1b01d";
    const TOKEN = decodeURIComponent(RAW_TOKEN);

    // viewer + user filters
    const USERNAME = "HKocen";
    const START_IMAGE_ID = (qs.get("image") || "744575191439794").trim();

    // date filters via URL
    const AFTER  = qs.get("after")  && /^\d{4}-\d{2}-\d{2}$/.test(qs.get("after"))  ? qs.get("after")  + "T00:00:00Z" : "";
    const BEFORE = qs.get("before") && /^\d{4}-\d{2}-\d{2}$/.test(qs.get("before")) ? qs.get("before") + "T23:59:59Z" : "";

    // perf knobs
    const PAGE_LIMIT       = 2000;   // Mapillary docs: default & max 2000
    const MAX_PINS_TOTAL   = 5000;   // cap per refresh
    const TILE_TARGET_AREA = 0.009;  // deg^2 (must be < 0.01)
    const MAX_TILES        = 512;    // guardrail
    const CONCURRENCY      = 8;      // parallel tile fetches
    const DEBOUNCE_MS      = 250;    // map move debounce
    const RETRIES          = 3;      // retry for 5xx
    const RETRY_BASE_MS    = 300;    // backoff base
    const CACHE_TTL_MS     = 5 * 60 * 1000; // 5 minutes
    const MOVE_HYSTERESIS  = 0.15;   // require ~15% bounds change to refetch

    // map start
    const START = { lat: 30.138307, lng: -91.965153, zoom: 14 };

    const $msg = (t)=>{ document.getElementById('msg').textContent = t || ""; };

    // ------------------ MAP ------------------
    const map = L.map('map', { zoomControl: true, attributionControl: true });
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    map.setView([START.lat, START.lng], START.zoom);

    const canvasRenderer = L.canvas({ padding: 0.5 });
    const pinLayer = L.featureGroup([], { renderer: canvasRenderer }).addTo(map);
    const marker = L.marker([START.lat, START.lng]).addTo(map);

    const pinStyle = { radius: 3.5, color: '#1b5e20', weight: 2, opacity: 1, fillColor: '#2ecc71', fillOpacity: 0.9, renderer: canvasRenderer };
    const pinStyleSel = { radius: 8, color: '#e53935', weight: 3, opacity: 1, fillColor: '#ffcdd2', fillOpacity: 1.0, renderer: canvasRenderer };

    let selectedPin = null, pinsById = new Map();
    const styleDefault  = (lyr)=>{ try{ lyr.setStyle(pinStyle); }catch{} };
    const styleSelected = (lyr)=>{ try{ lyr.setStyle(pinStyleSel); lyr.bringToFront(); }catch{} };
    function selectPinById(id){
      const lyr = pinsById.get(id);
      if (!lyr) return;
      if (selectedPin && selectedPin !== lyr) styleDefault(selectedPin);
      styleSelected(lyr);
      selectedPin = lyr;
    }

    // ------------------ UTIL ------------------
    const clampLon = x => Math.max(-180, Math.min(180, x));
    const clampLat = y => Math.max(-85,  Math.min(85,  y));
    function bboxFromMap(){
      const b = map.getBounds(); const sw = b.getSouthWest(), ne = b.getNorthEast();
      return [clampLon(sw.lng), clampLat(sw.lat), clampLon(ne.lng), clampLat(ne.lat)];
    }
    const bboxArea = ([W,S,E,N]) => Math.max(0,E-W) * Math.max(0,N-S);
    const splitBbox = ([W,S,E,N]) => { const mx=(W+E)/2, my=(S+N)/2; return [[W,S,mx,my],[mx,S,E,my],[W,my,mx,N],[mx,my,E,N]]; };
    function tileViewportBboxes(viewBbox){
      const out=[], q=[viewBbox];
      while(q.length && out.length<MAX_TILES){
        const b=q.shift();
        if (bboxArea(b) <= TILE_TARGET_AREA) out.push(b); else q.push(...splitBbox(b));
      }
      return out;
    }

    // Move hysteresis (skip tiny shifts)
    let lastBbox = null;
    function bboxChangedEnough(prev, curr){
      if (!prev) return true;
      const pb = L.latLngBounds([prev[1],prev[0]],[prev[3],prev[2]]);
      const cb = L.latLngBounds([curr[1],curr[0]],[curr[3],curr[2]]);
      const inter = pb.intersection(cb);
      if (!inter) return true;
      const aPrev = pb.getSize().x * pb.getSize().y;
      const aInt  = inter.getSize().x * inter.getSize().y;
      const overlap = aInt / aPrev;         // fraction of old bbox still visible
      return (1 - overlap) > MOVE_HYSTERESIS;
    }

    // ------------------ GRAPH API ------------------
    function buildImagesURL({bbox, limit}){
      const [W,S,E,N] = bbox.map(v => +v.toFixed(7));
      const u = new URL("https://graph.mapillary.com/images");
      u.searchParams.set("fields", "id,computed_geometry");
      u.searchParams.set("bbox", `${W},${S},${E},${N}`);  // W,S,E,N
      u.searchParams.set("limit", String(Math.min(PAGE_LIMIT, limit)));
      u.searchParams.set("access_token", TOKEN);
      u.searchParams.set("creator_username", USERNAME);
      if (AFTER)  u.searchParams.set("start_captured_at", AFTER);
      if (BEFORE) u.searchParams.set("end_captured_at", BEFORE);
      return u;
    }

    const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
    async function fetchWithRetry(url, {signal, tries=RETRIES}={}){
      for (let i=0;i<tries;i++){
        const res = await fetch(url, { signal });
        if (res.ok) return res;
        // Only back off on 5xx; surface 4xx immediately
        if (res.status >= 500) {
          const jitter = 0.5 + Math.random();
          await sleep(RETRY_BASE_MS * Math.pow(2,i) * jitter);
          continue;
        } else {
          const txt = await res.text().catch(()=>res.statusText);
          throw new Error(`${res.status} ${txt}`);
        }
      }
      const txt = `${url}`;
      throw new Error(`retry-exhausted for ${txt}`);
    }

    async function fetchTile({bbox, cap, signal}){
      const bboxStr = bbox.map(v => +v.toFixed(7)).join(",");
      const first = buildImagesURL({bbox, limit: Math.min(PAGE_LIMIT, cap)});
      let out = [];
      let url = first;

      while (url && out.length < cap){
        const res = await fetchWithRetry(url, { signal });
        const j = await res.json();

        const data = Array.isArray(j.data) ? j.data : [];
        for (const d of data){
          const c = d?.computed_geometry?.coordinates;
          if (Array.isArray(c) && c.length===2) out.push({ id: d.id, lng: c[0], lat: c[1] });
          if (out.length >= cap) break;
        }

        const next = j?.paging?.next;
        if (next && out.length < cap){
          url = new URL(next);

          // Re-attach filters (esp. bbox) + tighten limit
          if (!url.searchParams.get("access_token"))      url.searchParams.set("access_token", TOKEN);
          if (!url.searchParams.get("fields"))            url.searchParams.set("fields","id,computed_geometry");
          if (!url.searchParams.get("creator_username"))  url.searchParams.set("creator_username", USERNAME);
          if (!url.searchParams.get("start_captured_at") && AFTER)  url.searchParams.set("start_captured_at", AFTER);
          if (!url.searchParams.get("end_captured_at")   && BEFORE) url.searchParams.set("end_captured_at", BEFORE);
          if (!url.searchParams.get("bbox"))              url.searchParams.set("bbox", bboxStr);

          const remaining = cap - out.length;
          url.searchParams.set("limit", String(Math.min(PAGE_LIMIT, remaining)));
        } else {
          url = null;
        }
      }
      return out.slice(0, cap);
    }

    // ------------------ CACHE (per-bbox) ------------------
    const tileCache = new Map();  // key=bboxStr, val={ts,data, promise}
    function keyOf(b){ return b.map(v=>+v.toFixed(7)).join(","); }
    function getCached(b){
      const k = keyOf(b); const v = tileCache.get(k);
      if (!v) return null;
      if (v.promise) return v; // in-flight
      if (Date.now() - v.ts > CACHE_TTL_MS) { tileCache.delete(k); return null; }
      return v;
    }
    function setCached(b, data){
      const k = keyOf(b);
      tileCache.set(k, { ts: Date.now(), data });
    }
    function setPending(b, promise){
      const k = keyOf(b);
      tileCache.set(k, { promise });
    }

    // ------------------ PIN LOADER ------------------
    let aborter = null;

    async function drawPinsForView(){
      const currBbox = bboxFromMap();
      if (!bboxChangedEnough(lastBbox, currBbox)) return;   // tiny move -> skip
      lastBbox = currBbox.slice();

      if (aborter) aborter.abort();
      aborter = new AbortController();
      const { signal } = aborter;

      const tiles = tileViewportBboxes(currBbox);
      $msg(`Loading pins… tiles: ${tiles.length}\nUser: ${USERNAME}${AFTER?`\nAfter: ${AFTER}`:""}${BEFORE?`\nBefore: ${BEFORE}`:""}`);

      let remaining = MAX_PINS_TOTAL;
      const results = [];
      const seen = new Set();

      let idx = 0;
      async function worker(){
        while (!signal.aborted && remaining > 0 && idx < tiles.length){
          const i = idx++; const bbox = tiles[i];
          const capForTile = Math.min(PAGE_LIMIT, remaining);

          // cache / in-flight de-dupe
          const cached = getCached(bbox);
          if (cached && cached.data){
            for (const r of cached.data) {
              if (seen.has(r.id)) continue;
              seen.add(r.id); results.push(r); remaining--; if (remaining<=0) break;
            }
            continue;
          }
          if (cached && cached.promise){
            try{
              const data = await cached.promise;
              for (const r of data) {
                if (seen.has(r.id)) continue;
                seen.add(r.id); results.push(r); remaining--; if (remaining<=0) break;
              }
              continue;
            }catch{ /* ignore failed in-flight */ }
          }

          // fetch with retry + cache
          const p = (async()=>{
            try {
              const data = await fetchTile({ bbox, cap: capForTile, signal });
              setCached(bbox, data);
              return data;
            } catch (e) {
              // Failed tile — cache empty result for a short time to avoid hammering
              setCached(bbox, []);
              console.warn("Tile failed:", e.message || e);
              return [];
            }
          })();
          setPending(bbox, p);

          const data = await p;
          for (const r of data){
            if (seen.has(r.id)) continue;
            seen.add(r.id); results.push(r); remaining--; if (remaining<=0) break;
          }
        }
      }

      const workers = Array.from({length: Math.min(CONCURRENCY, tiles.length)}, worker);
      await Promise.all(workers).catch(()=>{});
      if (signal.aborted) return;

      // draw (Canvas)
      pinLayer.clearLayers(); pinsById.clear(); selectedPin = null;
      for (const r of results){
        const latlng = [r.lat, r.lng];
        const cm = L.circleMarker(latlng, pinStyle)
          .on("click", async (e)=>{
            L.DomEvent.stop(e);
            selectPinById(r.id);
            await gotoImage(r.id, latlng);
          });
        pinLayer.addLayer(cm);
        pinsById.set(r.id, cm);
      }
      const capped = results.length >= MAX_PINS_TOTAL ? " (capped)" : "";
      $msg(`Pins: ${results.length}${capped}\nTiles: ${tiles.length}`);
    }

    let timer=null;
    map.on("moveend", ()=>{ clearTimeout(timer); timer=setTimeout(drawPinsForView, DEBOUNCE_MS); });

    // ------------------ VIEWER ------------------
    const viewer = new mapillary.Viewer({ container: "mly", accessToken: TOKEN, imageId: START_IMAGE_ID, component: { cover: false, direction: true, zoom: true } });

    async function getImageLatLng(id){
      const u = new URL(`https://graph.mapillary.com/${id}`);
      u.searchParams.set("fields","computed_geometry");
      u.searchParams.set("access_token", TOKEN);
      try{
        const r = await fetchWithRetry(u, { tries: 2 });
        const j = await r.json();
        const c = j?.computed_geometry?.coordinates;
        return (Array.isArray(c) && c.length===2) ? [c[1], c[0]] : null;
      }catch{ return null; }
    }

    async function gotoImage(id, latlngHint){
      try{ await viewer.setFilter(["all"]); }catch{}
      await viewer.moveTo(id).catch(()=>{});
      const ll = latlngHint || await getImageLatLng(id);
      if (ll) { marker.setLatLng(ll); map.setView(ll, map.getZoom(), { animate:true }); }
    }

    // initial load
    (async function init(){
      try {
        await viewer.moveTo(START_IMAGE_ID);
      } catch {}
      drawPinsForView();
    })();
  </script>
</body>
</html>
