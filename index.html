<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mapillary – Hybrid (Tiles → ID batches) with safe IDs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapillaryJS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
  <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>

  <!-- MapLibre GL -->
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #wrap { position: relative; height: 100vh; width: 100%; }
    #viewer, #map { position: absolute; top: 0; height: 100%; }
    #viewer { left: 0; width: 61.8%; }
    #map    { right: 0; width: calc(38.2% - 2px); }
    #msg { position:absolute; left:8px; top:8px; z-index:1000; background:rgba(0,0,0,.72);
           color:#fff; padding:6px 10px; border-radius:6px; font:13px/1.3 system-ui,sans-serif;
           white-space:pre-line; max-width:min(52vw,780px); }
    #msg.error { background: rgba(160,0,0,.85); }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="viewer"></div>
    <div id="map"></div>
    <div id="msg">Loading…</div>
  </div>

  <script>
    // ===== CONFIG =====
    const TOKEN    = "MLY|24840280672250420|6fc0e204403850a11ccc043866f1b01d";
    const START_ID = "744575191439794";

    const USERNAME = "HKocen";
    const AFTER    = "2025-06-01T00:00:00Z"; // after May 31, 2025

    // Tile → ID sampling + filtering limits
    const CANDIDATE_LIMIT = 8000;  // max visible candidates read from tiles
    const MAX_FILTERED    = 5000;  // final pins to render

    // Graph batching
    const BATCH_SIZE   = 100;      // ids per request
    const CONCURRENCY  = 6;        // parallel requests
    const MIN_ZOOM_TO_SCAN = 14;
    const DEBOUNCE_MS  = 250;

    const FIELDS = "id,creator,captured_at,computed_geometry"; // exact fields, no typos

    const $msg = document.getElementById("msg");
    const status = (t, err=false)=>{ $msg.textContent=t||""; $msg.classList.toggle("error", !!err); };

    // ===== Viewer (left) =====
    const viewer = new mapillary.Viewer({
      container: "viewer",
      accessToken: TOKEN,
      imageId: START_ID,
      component: { cover:false, direction:true, zoom:true, attribution:true }
    });

    // ===== Map (right) =====
    const style = {
      "version": 8,
      "glyphs": "https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf",
      "sources": {
        "osm": {
          "type": "raster",
          "tiles": ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
          "tileSize": 256, "minzoom": 0, "maxzoom": 19,
          "attribution": "© OpenStreetMap contributors"
        },
        "mapillary": {
          "type": "vector",
          "tiles": [
            "https://tiles.mapillary.com/maps/vtp/mly1_public/2/{z}/{x}/{y}?access_token=" + encodeURIComponent(TOKEN)
          ],
          "minzoom": 0,
          "maxzoom": 14
        }
      },
      "layers": [
        { "id": "bg",  "type": "background", "paint": { "background-color": "#e6f2d8" } },
        { "id": "osm", "type": "raster", "source": "osm" }
      ]
    };

    const map = new maplibregl.Map({
      container: "map",
      style,
      center: [-91.965153, 30.138307],
      zoom: 15
    });

    map.on("load", () => {
      // sequences for context
      map.addLayer({
        id: "mly-sequences",
        type: "line",
        source: "mapillary",
        "source-layer": "sequence",
        minzoom: 13,
        paint: {
          "line-color": "#1976d2",
          "line-opacity": 0.5,
          "line-width": ["interpolate", ["linear"], ["zoom"], 13, 1, 17, 2.5]
        }
      });

      // faint all-image dots for querying IDs
      map.addLayer({
        id: "mly-images-all",
        type: "circle",
        source: "mapillary",
        "source-layer": "image",
        minzoom: 14,
        paint: {
          "circle-color": "#999",
          "circle-opacity": 0.12,
          "circle-radius": ["interpolate", ["linear"], ["zoom"], 14, 1.5, 18, 3.0]
        }
      });

      // filtered pins layer
      map.addSource("filteredPins", {
        type: "geojson",
        data: { type:"FeatureCollection", features: [] }
      });
      map.addLayer({
        id: "filtered-pins",
        type: "circle",
        source: "filteredPins",
        paint: {
          "circle-color": "#1b5e20",
          "circle-opacity": 0.95,
          "circle-radius": ["interpolate", ["linear"], ["zoom"], 14, 2.5, 18, 5.0],
          "circle-stroke-width": 2,
          "circle-stroke-color": "#b6ffb6"
        }
      });

      map.on("click", "filtered-pins", (e) => {
        const f = map.queryRenderedFeatures(e.point, { layers:["filtered-pins"] })[0];
        if (f?.properties?.id) viewer.moveTo(String(f.properties.id)).catch(()=>{});
      });
      map.on("mouseenter", "filtered-pins", ()=> map.getCanvas().style.cursor = "pointer");
      map.on("mouseleave", "filtered-pins", ()=> map.getCanvas().style.cursor = "");

      refreshFilteredPins();
    });

    // ===== Safe ID extraction from tiles =====
    function toSafeIdString(props){
      // Prefer string key fields from tiles (no precision loss)
      const key = props?.key || props?.image_key || props?.imageId || props?.image_id;
      if (key) return String(key);

      // Fall back to numeric id ONLY if it’s a safe integer
      const n = props?.id;
      if (typeof n === "number" && Number.isSafeInteger(n)) return String(n);

      // Some tiles expose an 'id' as string already – keep it
      if (typeof props?.id === "string") return props.id;

      return null; // unsafe → skip
    }

    function getVisibleImageIds() {
      if (map.getZoom() < MIN_ZOOM_TO_SCAN) return [];
      const feats = map.queryRenderedFeatures({ layers: ["mly-images-all"] });

      const ids = [];
      const seen = new Set();
      const step = Math.max(1, Math.floor(feats.length / CANDIDATE_LIMIT));

      for (let i = 0; i < feats.length; i += step) {
        const f = feats[i];
        const idStr = toSafeIdString(f.properties || {});
        if (!idStr || seen.has(idStr)) continue;
        seen.add(idStr);
        ids.push(idStr);
        if (ids.length >= CANDIDATE_LIMIT) break;
      }
      return ids;
    }

    // ===== Graph API batching (always /images?ids=…) =====
    async function fetchIdsChunk(ids){
      const u = new URL("https://graph.mapillary.com/images");
      u.searchParams.set("ids", ids.join(","));
      u.searchParams.set("fields", FIELDS);
      u.searchParams.set("access_token", TOKEN);
      const r = await fetch(u);
      if (!r.ok) throw new Error(`${r.status}`);
      const j = await r.json();
      return Array.isArray(j.data) ? j.data : [];
    }

    // Split batches recursively if a chunk fails, down to size 1.
    async function fetchMetaForIds(ids){
      const out = [];
      let idx = 0;

      async function worker(){
        while (idx < ids.length){
          const start = idx;
          const end   = Math.min(ids.length, start + BATCH_SIZE);
          idx = end;
          const chunk = ids.slice(start, end);

          // recursive fetch with split-on-error
          async function fetchSplit(list){
            if (list.length === 0) return;
            try {
              const arr = await fetchIdsChunk(list);
              out.push(...arr);
            } catch (e) {
              if (list.length === 1) {
                // give up on this id; it may have been imprecise or removed
                // console.warn("Skip id", list[0], e.message);
                return;
              }
              const mid = Math.floor(list.length/2);
              await fetchSplit(list.slice(0, mid));
              await fetchSplit(list.slice(mid));
            }
          }
          await fetchSplit(chunk);
        }
      }
      await Promise.all(Array.from({length: Math.min(CONCURRENCY, Math.ceil(ids.length/BATCH_SIZE))}, worker));
      return out;
    }

    // Metadata cache (avoid re-fetching when panning)
    const metaCache = new Map(); // id -> {ts, m}
    const CACHE_TTL_MS = 5 * 60 * 1000;
    function getCachedMeta(ids){
      const fresh = [], missing = [];
      const now = Date.now();
      for (const id of ids) {
        const v = metaCache.get(id);
        if (v && (now - v.ts) < CACHE_TTL_MS) fresh.push(v.m);
        else missing.push(id);
      }
      return { fresh, missing };
    }
    function putCachedMeta(items){
      const ts = Date.now();
      for (const m of items) {
        const id = String(m?.id || "");
        if (id) metaCache.set(id, { ts, m });
      }
    }

    // ===== Main refresh =====
    let refreshTimer = null, generation = 0;
    function scheduleRefresh(){ clearTimeout(refreshTimer); refreshTimer=setTimeout(refreshFilteredPins, DEBOUNCE_MS); }
    map.on("moveend", scheduleRefresh);
    map.on("zoomend", scheduleRefresh);

    async function refreshFilteredPins(){
      if (!map.getSource("filteredPins")) return;

      if (map.getZoom() < MIN_ZOOM_TO_SCAN) {
        status(`Zoom in to ≥ ${MIN_ZOOM_TO_SCAN} to scan.\nUser: ${USERNAME}\nAfter: ${AFTER}`);
        map.getSource("filteredPins").setData({ type:"FeatureCollection", features: [] });
        return;
      }

      const gen = ++generation;
      const ids = getVisibleImageIds();
      if (!ids.length) {
        status(`No tile points visible. Try zooming in.\nUser: ${USERNAME}\nAfter: ${AFTER}`);
        map.getSource("filteredPins").setData({ type:"FeatureCollection", features: [] });
        return;
      }
      status(`Scanning ${ids.length} tile points…\nFiltering for ${USERNAME} & after ${AFTER}`);

      // cache-aware fetch
      const { fresh, missing } = getCachedMeta(ids.slice(0, MAX_FILTERED*2));
      let meta = fresh;
      if (missing.length) {
        const fetched = await fetchMetaForIds(missing);
        putCachedMeta(fetched);
        meta = meta.concat(fetched);
        if (gen !== generation) return; // superseded by a newer run
      }

      const cutoff = Date.parse(AFTER);
      const feats = [];
      const seen = new Set();

      for (const m of meta) {
        const id = String(m?.id || "");
        if (!id || seen.has(id)) continue;
        const uname = m?.creator?.username || "";
        const ts = m?.captured_at ? Date.parse(m.captured_at) : NaN;
        const coord = m?.computed_geometry?.coordinates;
        if (!Array.isArray(coord) || coord.length !== 2) continue;
        if (uname !== USERNAME) continue;
        if (!Number.isNaN(ts) && ts < cutoff) continue;

        feats.push({
          type: "Feature",
          geometry: { type: "Point", coordinates: [coord[0], coord[1]] },
          properties: { id }
        });
        seen.add(id);
        if (feats.length >= MAX_FILTERED) break;
      }

      map.getSource("filteredPins").setData({ type:"FeatureCollection", features: feats });
      const capped = feats.length >= MAX_FILTERED ? " (capped)" : "";
      status(`Showing ${feats.length}${capped} pins\nUser: ${USERNAME}\nAfter: ${AFTER}`);
    }

    // ===== keep a small dot in sync with the viewer position (optional) =====
    const posDot = document.createElement('div'); posDot.style.cssText="width:14px;height:14px;border:3px solid #ff2a6d;border-radius:50%;background:#fff9";
    const positionMarker = new maplibregl.Marker({ element: posDot, rotationAlignment: "map" });
    async function syncPosition(){
      try{
        const p = await viewer.getPosition();
        positionMarker.setLngLat([p.lng,p.lat]).addTo(map);
      }catch{}
    }
    viewer.on('load', syncPosition);
    viewer.on('image', syncPosition);
  </script>
</body>
</html>
